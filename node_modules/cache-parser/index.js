!(function (root) {
  /** Unique identifier */
  var symbolKey = Symbol('cache-parser');

  /** (camelCase=kebabCase) and (kebabCase=camelCase) */
  var Directive = {
    immutable: 'immutable',
    maxAge: 'max-age',
    maxStale: 'max-stale',
    minFresh: 'min-fresh',
    mustRevalidate: 'must-revalidate',
    mustUnderstand: 'must-understand',
    noCache: 'no-cache',
    noStore: 'no-store',
    noTransform: 'no-transform',
    onlyIfCached: 'only-if-cached',
    private: 'private',
    proxyRevalidate: 'proxy-revalidate',
    public: 'public',
    sMaxAge: 's-maxage',
    staleIfError: 'stale-if-error',
    staleWhileRevalidate: 'stale-while-revalidate'
  };

  for (var key in Directive) {
    Directive[Directive[key]] = key;
  }

  function toDuration(val) {
    return (
      (typeof val === 'string' || typeof val === 'number') &&
      (val = Number(val)) >= 0 &&
      val < Infinity
    );
  }

  function toBoolean(val) {
    return (
      val === true ||
      typeof val === 'number' ||
      (typeof val === 'string' && val !== 'false')
    );
  }

  function isCacheControl(cache) {
    return !!cache && !!cache[symbolKey];
  }

  function tokenize(header) {
    if (!header || typeof header !== 'object') {
      return [];
    }

    var tokens = [];

    toBoolean(header.immutable) && tokens.push(Directive.immutable);

    toDuration(header.maxAge) &&
      tokens.push(Directive.maxAge + '=' + Number(header.maxAge));

    toDuration(header.maxStale) &&
      tokens.push(Directive.maxStale + '=' + Number(header.maxStale));

    toDuration(header.minFresh) &&
      tokens.push(Directive.minFresh + '=' + Number(header.minFresh));

    toBoolean(header.mustRevalidate) && tokens.push(Directive.mustRevalidate);
    toBoolean(header.mustUnderstand) && tokens.push(Directive.mustUnderstand);
    toBoolean(header.noCache) && tokens.push(Directive.noCache);
    toBoolean(header.noStore) && tokens.push(Directive.noStore);
    toBoolean(header.noTransform) && tokens.push(Directive.noTransform);
    toBoolean(header.onlyIfCached) && tokens.push(Directive.onlyIfCached);
    toBoolean(header.private) && tokens.push(Directive.private);
    toBoolean(header.proxyRevalidate) && tokens.push(Directive.proxyRevalidate);
    toBoolean(header.public) && tokens.push(Directive.public);

    toDuration(header.sMaxAge) &&
      tokens.push(Directive.sMaxAge + '=' + Number(header.sMaxAge));
    toDuration(header.staleIfError) &&
      tokens.push(Directive.staleIfError + '=' + Number(header.staleIfError));
    toDuration(header.staleWhileRevalidate) &&
      tokens.push(
        Directive.staleWhileRevalidate + '=' + Number(header.staleWhileRevalidate)
      );

    return tokens;
  }

  function parse(headerStr) {
    var header = Object.defineProperty({}, symbolKey, {
      configurable: false,
      enumerable: false,
      writable: false,
      value: 1
    });

    if (!headerStr || typeof headerStr !== 'string') {
      return header;
    }

    /** (kebabName=rawValue) */
    var rawHeaders = {};
    var tokens = headerStr.toLowerCase().replace(/\s+/g, '').split(',');

    for (var i in tokens) {
      var token = tokens[i].split('=', 2);

      rawHeaders[token[0]] = token.length === 1 ? true : token[1];
    }

    toBoolean(rawHeaders[Directive.immutable]) && (header.immutable = true);

    toDuration(rawHeaders[Directive.maxAge]) &&
      (header.maxAge = Number(rawHeaders[Directive.maxAge]));
    toDuration(rawHeaders[Directive.maxStale]) &&
      (header.maxStale = Number(rawHeaders[Directive.maxStale]));
    toDuration(rawHeaders[Directive.minFresh]) &&
      (header.minFresh = Number(rawHeaders[Directive.minFresh]));

    toBoolean(rawHeaders[Directive.mustRevalidate]) && (header.mustRevalidate = true);
    toBoolean(rawHeaders[Directive.mustUnderstand]) && (header.mustUnderstand = true);
    toBoolean(rawHeaders[Directive.noCache]) && (header.noCache = true);
    toBoolean(rawHeaders[Directive.noStore]) && (header.noStore = true);
    toBoolean(rawHeaders[Directive.noTransform]) && (header.noTransform = true);
    toBoolean(rawHeaders[Directive.onlyIfCached]) && (header.onlyIfCached = true);
    toBoolean(rawHeaders[Directive.private]) && (header.private = true);
    toBoolean(rawHeaders[Directive.proxyRevalidate]) && (header.proxyRevalidate = true);
    toBoolean(rawHeaders[Directive.public]) && (header.public = true);

    toDuration(rawHeaders[Directive.sMaxAge]) &&
      (header.sMaxAge = Number(rawHeaders[Directive.sMaxAge]));
    toDuration(rawHeaders[Directive.staleIfError]) &&
      (header.staleIfError = Number(rawHeaders[Directive.staleIfError]));
    toDuration(rawHeaders[Directive.staleWhileRevalidate]) &&
      (header.staleWhileRevalidate = Number(rawHeaders[Directive.staleWhileRevalidate]));

    return header;
  }

  root.Directive = Directive;
  root.toDuration = toDuration;
  root.toBoolean = toBoolean;

  root.isCacheControl = isCacheControl;
  root.tokenize = tokenize;
  root.parse = parse;
})(
  typeof exports !== 'undefined'
    ? exports
    : window.CacheParser || (window.CacheParser = {})
);
